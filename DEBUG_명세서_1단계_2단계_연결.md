# Debug 명세서: 1단계 ↔ 2단계 연결

**작성일**: 2026-02-02  
**목적**: Phase 2에서 1단계(Google Sheets 고급 기능)와 2단계(실시간 데이터 연동 API) 연결 구간의 디버그·개선 사항 정리

---

## 1. 개요

- **1단계**: 데이터 검증(1-1), 조건부 서식(1-2), VLOOKUP 수식(1-3) — 시트1은 **17컬럼 → 22컬럼**으로 변경됨.
- **2단계**: API가 시트1을 **22컬럼 기준**으로 읽기/쓰기 (`sheets_service`, `routes/sites.py`).
- **연결 이슈**: 1-1/1-2는 **17컬럼 기준** 컬럼 문자·인덱스를 사용하므로, **1-3(VLOOKUP) 적용 후** 1-1/1-2를 다시 실행하면 잘못된 열에 검증·서식이 적용됨.

---

## 2. 발견된 Debug/개선 사항

### 2.1 시트1 컬럼 레이아웃 불일치 (17 vs 22)

| 구분 | 17컬럼 (1-3 적용 전) | 22컬럼 (1-3 적용 후) | 비고 |
|------|----------------------|----------------------|------|
| 배정상태 | O (14) | **T (19)** | 1-1, 1-2는 O/14 사용 → 22컬럼 시 잘못된 열 |
| 등록일 | P (15) | **U (20)** | 1-1은 P,Q 사용 → 22컬럼 시 P,Q는 자격증소유자명/연락처 |
| 수정일 | Q (16) | **V (21)** | 동일 |
| 사용자격증ID | M (12) | **O (14)** | API는 22컬럼 기준 O 사용 (일치) |

**영향**  
- 1-3 실행 **이후** 1-1(데이터 검증)만 다시 실행하면: 배정상태 검증이 **O열(사용자격증ID)**에 적용됨.  
- 1-3 실행 **이후** 1-2(조건부 서식)만 다시 실행하면: 배정상태 서식이 **14번 열(O=사용자격증ID)**에 적용됨.  
- 2단계 API는 항상 22컬럼 기준(L,O,T,V 등)으로 동작하므로, 시트가 22컬럼이면 API와 1-1/1-2 간 불일치 발생.

**권장**  
- 1-1, 1-2에서 **시트1의 현재 컬럼 수**를 읽어 17이면 기존(O, P, Q, 인덱스 14), 22이면 T, U, V(인덱스 19, 20, 21) 사용.  
- 또는 **실행 순서 고정**: 1-1 → 1-2 → 1-3 순으로만 실행하고, 1-3 이후에는 1-1/1-2를 “22컬럼 버전”으로만 재실행하도록 문서화.

---

### 2.2 SPREADSHEET_ID 하드코딩

| 파일 | 위치 | 내용 |
|------|------|------|
| `apply_data_validation.py` | 상단 | `SPREADSHEET_ID = '15fAEzkC9FCLA6sG1N--...'` (문자열 하드코딩) |

**영향**  
- 다른 스프레드시트로 전환 시 코드 수정 필요.  
- 2단계 API·1-2/1-3은 `os.getenv('SPREADSHEET_ID')` 사용으로 일관성 부족.

**권장**  
- `apply_data_validation.py`에서도 `os.getenv('SPREADSHEET_ID', '').strip()` 사용.  
- 값 없을 때 명확한 에러 메시지로 `.env` 설정 안내.

---

### 2.3 2단계 API 로깅·에러 추적 부재

| 구분 | 현황 | 권장 |
|------|------|------|
| 500/404 응답 | Flask 기본 처리, 요청 ID 없음 | 요청별 `request_id`(또는 correlation_id) 부여, 로그에 `request_id`, `error_code`, `site_id` 등 기록 |
| 예외 상세 | `str(e)`만 반환/로그 | 개발 환경에서만 상세 메시지, 운영에서는 코드+요약 메시지 |
| Sheets API 실패 | 예외 발생 시 스택만 가능 | `sheets_service.read_sheet` 실패 시 `error_code`, `range` 등 구조화 로그 |

**영향**  
- 1단계 시트와 2단계 API 간 데이터 불일치·오류 발생 시 원인 추적이 어려움.

**권장**  
- `app.py` 또는 미들웨어에서 요청 진입 시 `request_id` 생성.  
- `errorhandler(500)` 등에서 `request_id`, `error.code`, `path`, `method` 로그 출력.  
- (선택) `sheets_service` 내 read_sheet 실패 시 로그에 `range_name`, `spreadsheet_id` 마스킹 값 기록.

---

### 2.4 시트1 컬럼 수 17/22 이외 구간 미처리

| 구분 | 현황 | 권장 |
|------|------|------|
| `sheets_service.get_all_sites()` | `n < 17` → 17 패딩, `n >= 17` → 22 패딩 | 18~21컬럼 등 중간 값은 현재 else로 22 처리. 실제 시트가 20컬럼이면 인덱스 18,19 등이 잘못된 필드와 매핑될 수 있음. |

**권장**  
- 문서에 “시트1은 17컬럼(기본) 또는 22컬럼(VLOOKUP 적용)만 지원” 명시.  
- (선택) 런타임에 첫 행 길이 검사 후 17/22가 아니면 경고 로그 또는 명확한 에러 반환.

---

### 2.5 1단계 실행 순서·전제 조건 문서화 부족

| 구분 | 현황 | 권장 |
|------|------|------|
| 1-1, 1-2, 1-3 순서 | 각 가이드에 흩어져 있음 | `Phase2_1단계_실행가이드.md` 등에 “권장 순서: 1-1 → 1-2 → 1-3. 1-3 적용 후 1-1/1-2 재실행 시 시트가 22컬럼임을 전제로 스크립트 동작” 명시. |
| 시트 구조 전제 | 2단계 API는 22컬럼 기준 | “2단계 API 사용 시 시트1은 22컬럼(VLOOKUP 적용) 상태여야 함”을 2단계 개요·가이드에 명시. |

---

## 3. 개선 작업 요약

| 우선순위 | 항목 | 조치 |
|----------|------|------|
| 높음 | 2.1 시트1 17/22 불일치 | 1-1, 1-2에서 시트1 컬럼 수 감지 후 컬럼 매핑 분기(17→O,P,Q/14, 22→T,U,V/19,20,21) |
| 높음 | 2.2 SPREADSHEET_ID | apply_data_validation.py에서 `.env` 사용, 하드코딩 제거 |
| 중간 | 2.3 API 로깅 | 요청 ID 부여, 500/404 시 구조화 로그 (request_id, error_code, path) |
| 낮음 | 2.4 컬럼 수 검증 | 문서화 및 (선택) 17/22 이외 시 경고 또는 에러 |
| 낮음 | 2.5 실행 순서 | Phase2 1단계·2단계 가이드에 실행 순서·전제 조건 보강 |

---

## 4. 수정/추가된 파일 (개선 반영 완료)

| 파일 | 반영 내용 |
|------|-----------|
| `apply_data_validation.py` | SPREADSHEET_ID → `.env` 사용, 빈 값 시 안내 메시지. 시트1 컬럼 수 감지(`get_sheet1_column_count`) 후 배정상태/등록일/수정일 컬럼 분기(17→O,P,Q / 22→T,U,V). |
| `apply_conditional_formatting.py` | 시트1 컬럼 수 감지 후 `apply_sheet1_formatting(sheet_id, sheet1_col_count)` 호출. 배정상태 컬럼 인덱스 분기(17→14, 22→19). |
| `api/app.py` | `before_request`에서 요청별 `request_id` 부여(`g.request_id`). 404/500 응답에 `error.request_id` 포함. 404/500 시 구조화 로그(`path`, `method`, `request_id`, 500 시 `logger.exception`). |

---

## 5. 검증 방법

- **2.1**: 1-3 적용된 22컬럼 시트에서 1-1, 1-2 재실행 → 배정상태 검증/서식이 T열에 적용되는지 확인.  
- **2.2**: `.env`만 변경 후 1-1 실행 → 해당 SPREADSHEET_ID 시트에 검증 적용되는지 확인.  
- **2.3**: API에서 의도적으로 500/404 유발 → 로그에 request_id, error_code 등 출력되는지 확인.
